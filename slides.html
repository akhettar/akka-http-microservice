<!DOCTYPE html>
<html>
<head>
    <title>Testing microservices built with Akka HTTP and Akka actors</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);
      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
</head>
<body>
<textarea id="source">
class: center, middle

# Testing microservices
### built with Akka HTTP and Akka actors

---

class: middle

>>>>>>># Agenda

>>>>>>- Introduction
- Background, reason
- Unit testing
- API testing
- Integration testing
- What next
- Questions

---

class: middle

>>>>>># Introduction

>- Building software for over 15 years
- Fullstack, lately more backend
- Currently at Hotels.com in the SEM Tools team
- Twitter: @TudorPalanga
- Github: https://github.com/tpalanga

---

class: middle

>>>># Background and reason
- Akka actors are not typed
- Actor behaviour can mutate
- Maintaining API contracts
- Sparse testing documentation
- What this is not

---
class: center, middle

# Unit testing

---
### Actor testing - actor implementation

```scala
object SubscriberService {

  sealed trait Request
  case class GetOne(id: UserId) extends Request
  case class AddOne(subscriber: Subscriber) extends Request

  sealed trait GetSubscriberResponse
  case class OneSubscriber(subscriber: Subscriber) extends GetSubscriberResponse
  case class NotFound(id: UserId) extends GetSubscriberResponse

  def props() = Props(new SubscriberService)
}

class SubscriberService extends Actor {
  private var subscribers: Map[UserId, Subscriber] = Map.empty

  override def receive: Receive = {
    case GetOne(id) =>
      sender() ! subscribers.get(id).map(OneSubscriber).getOrElse(NotFound(id))
  }
}
```

---
### Actor testing - test setup

```scala
object SubscriberServiceSpec {

  abstract class Test(implicit val system: ActorSystem) {
    val subscriberService: ActorRef = system.actorOf(SubscriberService.props())
  }

  trait TestWithCreatedSubscribers extends Test with Matchers {
    val requester = TestProbe()
    val newSubscribers = Seq(
      Subscriber("u01", "user 1", "user1@test.com"),
      Subscriber("u02", "user 2", "user2@test.com"),
      Subscriber("u03", "user 3", "user3@test.com")
    )
    val createdSubscribers = newSubscribers.map { subscriber =>
      subscriberService.tell(SubscriberService.AddOne(subscriber), requester.ref)
      val createdSubscriber =
        requester.expectMsgType[SubscriberService.OneSubscriber]
      createdSubscriber.subscriber.name shouldBe subscriber.name
      createdSubscriber.subscriber
    }
  }
}

```
---
### Actor testing - test cases

```scala
class SubscriberServiceSpec extends TestKit(ActorSystem("SubscriberServiceSpec"))
    with FlatSpecLike with Matchers with ImplicitSender with OptionValues {
  import SubscriberServiceSpec._

  "SubscriberService" should "retrieve a subscriber that already exists" in
      new TestWithCreatedSubscribers {
    val testSubscriber = createdSubscribers.headOption.value
    subscriberService ! SubscriberService.GetOne(testSubscriber.id)
    expectMsg(SubscriberService.OneSubscriber(testSubscriber))
  }

  it should "reply NotFound when attempting to retrieve a subscriber that does not exist" in
      new TestWithCreatedSubscribers {
    val testSubscriber = createdSubscribers.headOption.value
    subscriberService ! SubscriberService.GetOne("unknown")
    expectMsg(SubscriberService.NotFound("unknown"))
  }
}
```

---
### Route testing - implementation

```scala
class SubscriberRoute(subscriberService: ActorRef) extends SprayJsonSupport {
  import Subscriber.DataFormats._
  import SubscriberService.DataFormats._

  implicit val askTimeout = Timeout(3.seconds)

  val route: Route =
    pathPrefix("data" / "subscribers") {
      path(Segment) { id =>
        pathEnd {
          get {
            // get id
            onComplete((subscriberService ? SubscriberService.GetOne(id))
                .mapTo[SubscriberService.GetSubscriberResponse]) {
              case Success(oneSubscriber: SubscriberService.OneSubscriber) =>
                complete(oneSubscriber.subscriber)

              case Success(SubscriberService.NotFound(_)) =>
                complete(StatusCodes.NotFound, s"Subscriber with ID $id not found")

              case Failure(th) =>
                complete(StatusCodes.InternalServerError, s"$msg: ${th.getMessage}")
            }
          }
        } ~
        put { ... }
    ...
  }
```

---
### Route testing - unit test

```scala
object SubscriberRouteSpec {
  val userId = "ABC-123"
  val testSubscriber = Subscriber(userId, "my test user", "test@test.com")

  abstract class Test(implicit system: ActorSystem) {
    protected val subscriberService = TestProbe()
    protected val route: Route = new SubscriberRoute(subscriberService.ref).route
  }
}

class SubscriberRouteSpec extends WordSpec with ScalatestRouteTest with SprayJsonSupport with Matchers with Eventually {
  import Subscriber.DataFormats._
  import SubscriberRouteSpec._

  implicit override val patienceConfig = PatienceConfig(timeout = scaled(Span(2, Seconds)), interval = scaled(Span(100, Millis)))
  private val longPatienceConfig = PatienceConfig(timeout = scaled(Span(5, Seconds)), interval = scaled(Span(100, Millis)))

  "SubscriberRoute" when {
    "receiving a subscriber GET request" should {
      "respond with the subscriber data if the subscriber exists" in new Test {
        Get(s"/data/subscribers/$userId") ~> route ~> check {
          subscriberService.expectMsg(SubscriberService.GetOne(userId))
          subscriberService.reply(SubscriberService.OneSubscriber(testSubscriber))
          eventually { status shouldEqual StatusCodes.OK }
          responseAs[Subscriber] should be(testSubscriber)
        }
      }
  ...
}
```

---
### Code coverage

```bash
  sbt "; project newsletterService; clean; coverage; test; coverageReport"
```
Generates the HTML/XML/Cobertura report in:

```bash
  newsletterService/target/scala-2.11/scoverage-report/
```
---

### What code coverage doesn't show
- shared partial functions between states
  >(error/timeout handling)
- shared functions

---

### Message not handled - override unhandled
---

### Message not handled - subscribe to events

---

### Race conditions [TODO]
- messages changing states

---

### Long timeouts, overriding config
- ask pattern


---

### Composing/linking actors
- long living actors
- ad-hoc created actors
- factories
---

### Futures, pipe [TODO]

---

# API testing
- reason
- setup
- docker [TODO]

---

# Integration testing
- reason
- setup
- docker [TODO]

---
class: center, middle
# Difference with mocking/stubbing

---
class: middle
>>>>>>># What next?

>>>>- Find the project on github
  https://github.com/tpalanga/akka-http-microservice
- Join me and contribute - PRs/feedback
- TODO: Akka cluster

---
class: center, middle
# Questions?

</textarea>
<script src="remark-latest.min.js" type="text/javascript">
</script>
<script type="text/javascript">
      var slideshow = remark.create();
    </script>
</body>
</html>